%skeleton "lalr1.cc"
%require "3.3"

// Parser options

%defines
%define api.namespace { rbs_parser }
%define api.parser.class { Parser }
%define api.value.type { Node* }
%define parse.error verbose

%locations
%parse-param { Driver& driver } { Lexer& lexer }

%code requires {
  #include "ast.hh"
  #include <exception>
  #include <sstream>

  namespace rbs_parser {
    class Driver;
    class Lexer;

    class ParseError: public std::logic_error {
    public:
        ParseError(const std::string &message) : logic_error(message) {}
        ParseError(const char *message) : logic_error(message) {}
    };
  }
}

%code {
  #include "Lexer.hh"
  #include "Driver.hh"
  #define yylex lexer.lex
}

%token tEOF 0
%token tERROR 1

// Tokens
%token tGLOBALIDENT
%token tINTEGER
%token tINTERFACEIDENT
%token tIVAR
%token tLIDENT
%token tLKEYWORD
%token tNAMESPACE
%token tQUOTEDIDENT
%token tQUOTEDMETHOD
%token tSTRING
%token tSYMBOL
%token tUIDENT
%token tUKEYWORD
%token tEXCLMETHOD

// Keywords
%token kALIAS
%token kANY
%token kATTRACCESSOR
%token kATTRREADER
%token kATTRWRITER
%token kBOOL
%token kBOT
%token kCLASS
%token kDEF
%token kEND
%token kEXTEND
%token kEXTENSION
%token kFALSE
%token kIN
%token kINCLUDE
%token kINCOMPATIBLE
%token kINSTANCE
%token kINTERFACE
%token kMODULE
%token kNIL
%token kOUT
%token kPREPEND
%token kPRIVATE
%token kPUBLIC
%token kSELF
%token kSELFQ
%token kSINGLETON
%token kSUPER
%token kTOP
%token kTRUE
%token kTYPE
%token kUNCHECKED
%token kUNTYPED
%token kVOID

// Punctuation
%token kAMP
%token kARROW
%token kBAR
%token kCOLON
%token kCOLON2
%token kCOMMA
%token kDOT
%token kEQ
%token kEXCLAMATION
%token kFATARROW
%token kHAT
%token kLBRACE
%token kLBRACKET
%token kLPAREN
%token kLT
%token kOPERATOR
%token kQUESTION
%token kRBRACE
%token kRBRACKET
%token kRPAREN
%token kSTAR
%token kSTAR2

// Precedence
%nonassoc kQUESTION
%left kAMP
%left kBAR
%nonassoc kARROW

%expect 3

// Productions
%%

  target
    : signatures tEOF

  signatures
    : %empty
    | signatures signature

  signature
    : type_decl
    | const_decl
    | extension_decl
    | global_decl
    | interface_decl
    | module_decl
    | class_decl

  // Types

  type_decl
    : kTYPE qualified_name kEQ type
    { driver.file->decls.push_back(new TypeDecl(driver.loc(@1, @4), driver.string($2), driver.type($4))); }

  // Consts

  const_decl
    : class_name kCOLON type
    { driver.file->decls.push_back(new Const(driver.loc(@1, @3), driver.string($1), driver.type($3))); }
    | namespace tUKEYWORD type
    {
      static_cast<Token*>($2)->str.pop_back();
      driver.file->decls.push_back(
        new Const(
          driver.loc(@1, @3),
          driver.string($1) + driver.string($2),
          driver.type($3)));
    }

  // Globals

  global_decl
    : tGLOBALIDENT kCOLON type
    { driver.file->decls.push_back(new Global(driver.loc(@1, @3), driver.string($1), driver.type($3))); }

  // Extensions

  extension_decl
    : kEXTENSION class_name module_type_params kLPAREN extension_name kRPAREN class_members kEND
    {
      Extension* decl = new Extension(driver.loc(@1, @8), driver.string($2), driver.string($5));
      decl->typeParams = driver.cast_list<TypeParam>(static_cast<NodeList*>($3));
      decl->members = driver.cast_list<Member>(static_cast<NodeList*>($7));
      driver.file->decls.push_back(decl);
    }

  extension_name
    : tUIDENT
    | tLIDENT

  // Modules

  module_decl
    : kMODULE class_name module_type_params module_self_type class_members kEND
    {
      Module* decl = new Module(driver.loc(@1, @6), driver.string($2));
      decl->typeParams = driver.cast_list<TypeParam>(static_cast<NodeList*>($3));
      decl->members = driver.cast_list<Member>(static_cast<NodeList*>($5));
      if ($4 != NULL) {
        decl->selfType = driver.type($4);
      }
      driver.file->decls.push_back(decl);
    }
    | kMODULE namespace tUKEYWORD type class_members kEND
    {
      static_cast<Token*>($3)->str.pop_back();
      Module* decl = new Module(driver.loc(@1, @6), driver.string($2) + driver.string($3));
      decl->selfType = driver.type($4);
      decl->members = driver.cast_list<Member>(static_cast<NodeList*>($5));
      driver.file->decls.push_back(decl);
    }

  module_self_type
    : %empty
    { $$ = NULL; }
    | kCOLON type
    { $$ = $2; }

  // Interfaces

  interface_decl
    : kINTERFACE interface_name module_type_params class_members kEND
    {
      Interface* decl = new Interface(driver.loc(@1, @5), driver.string($2));
      decl->typeParams = driver.cast_list<TypeParam>(static_cast<NodeList*>($3));
      decl->members = driver.cast_list<Member>(static_cast<NodeList*>($4));
      driver.file->decls.push_back(decl);
    }

  interface_name
    : namespace tINTERFACEIDENT
    { $$ = new Token(driver.loc(@1, @2), driver.string($1) + driver.string($2)); }

  // Classes

  class_decl
    : kCLASS class_name module_type_params super_class class_members kEND
    {
      Class* decl = new Class(driver.loc(@1, @6), driver.string($2), driver.string($4));
      decl->typeParams = driver.cast_list<TypeParam>(static_cast<NodeList*>($3));
      decl->members = driver.cast_list<Member>(static_cast<NodeList*>($5));
      driver.file->decls.push_back(decl);
    }

  super_class
    : %empty
    { $$ = NULL; }
    | kLT class_name
    { $$ = $2; }
    | kLT class_name kLBRACKET type_list kRBRACKET
    // TODO generics
    { $$ = $2; }

  class_name
    : namespace tUIDENT
    { $$ = new Token(driver.loc(@1, @2), driver.string($1) + driver.string($2)); }

  // Generics

  module_type_params
    : %empty
    { $$ = driver.list(); }
    | kLBRACKET module_type_params0 kRBRACKET
    { $$ = $2; }

  module_type_params0
    : module_type_param
    { $$ = driver.list(unique_ptr<Node>($1)); }
    | module_type_params0 kCOMMA module_type_param
    { $$ = driver.merge(static_cast<NodeList*>($1), unique_ptr<Node>($3)); }

  module_type_param
    : type_param_check type_param_variance tUIDENT
    { $$ = new TypeParam(driver.loc(@1, @3), driver.string($3), driver.string($2), $1 != NULL); }

  type_param_variance
    : %empty
    { $$ = NULL; }
    | kOUT
    | kIN

  type_param_check
    : %empty
    { $$ = NULL; }
    | kUNCHECKED

  // Class members

  class_members
    : %empty
    { $$ = driver.list(); }
    | class_members class_member
    { $$ = driver.merge(static_cast<NodeList*>($1), unique_ptr<Node>($2)); }

  class_member
    : alias_member
    | attribute_member
    | include_member
    | extend_member
    | prepend_member
    | kPUBLIC
    { $$ = new Visibility(driver.loc(@1, @1), driver.string($1)); }
    | kPRIVATE
    { $$ = new Visibility(driver.loc(@1, @1), driver.string($1)); }
    | method_member

  alias_member
    : kALIAS method_name method_name
    { $$ = new Alias(driver.loc(@1, @3), driver.string($2), driver.string($3), false); }
    | kALIAS kSELF kDOT method_name kSELF kDOT method_name
    { $$ = new Alias(driver.loc(@1, @7), driver.string($4), driver.string($7), true); }

  attribute_member
    : kATTRREADER keyword type
    { $$ = new AttrReader(driver.loc(@1, @3), driver.string($2), "", driver.type($3)); }
    | kATTRREADER method_name attr_var_opt kCOLON type
    { $$ = new AttrReader(driver.loc(@1, @5), driver.string($2), driver.string($3), driver.type($5)); }
    | kATTRWRITER keyword type
    { $$ = new AttrWriter(driver.loc(@1, @3), driver.string($2), "", driver.type($3)); }
    | kATTRWRITER method_name attr_var_opt kCOLON type
    { $$ = new AttrWriter(driver.loc(@1, @5), driver.string($2), driver.string($3), driver.type($5)); }
    | kATTRACCESSOR keyword type
    { $$ = new AttrAccessor(driver.loc(@1, @3), driver.string($2), "", driver.type($3)); }
    | kATTRACCESSOR method_name attr_var_opt kCOLON type
    { $$ = new AttrAccessor(driver.loc(@1, @5), driver.string($2), driver.string($3), driver.type($5)); }

  attr_var_opt
    : kLPAREN kRPAREN
    { $$ = NULL; }
    | kLPAREN tIVAR kRPAREN
    { $$ = $2; }

  include_member
    : kINCLUDE qualified_name
    { $$ = new Include(driver.loc(@1, @2), std::make_unique<TypeSimple>(driver.loc(@2, @2), driver.string($2))); }
    | kINCLUDE qualified_name kLBRACKET type_list kRBRACKET
    {
      std::unique_ptr<TypeGeneric> type = std::make_unique<TypeGeneric>(driver.loc(@2, @5), driver.string($2));
      type->types = driver.cast_list<Type>(static_cast<NodeList*>($4));
      $$ = new Include(driver.loc(@1, @5), std::unique_ptr<Type>(type.release()));
    }

  extend_member
    : kEXTEND qualified_name
    { $$ = new Extend(driver.loc(@1, @2), std::make_unique<TypeSimple>(driver.loc(@2, @2), driver.string($2))); }
    | kEXTEND qualified_name kLBRACKET type_list kRBRACKET
    {
      std::unique_ptr<TypeGeneric> type = std::make_unique<TypeGeneric>(driver.loc(@2, @5), driver.string($2));
      type->types = driver.cast_list<Type>(static_cast<NodeList*>($4));
      $$ = new Extend(driver.loc(@1, @5), std::unique_ptr<Type>(type.release()));
    }

  prepend_member
    : kPREPEND qualified_name
    { $$ = new Prepend(driver.loc(@1, @2), std::make_unique<TypeSimple>(driver.loc(@2, @2), driver.string($2))); }
    | kPREPEND qualified_name kLBRACKET type_list kRBRACKET
    {
      std::unique_ptr<TypeGeneric> type = std::make_unique<TypeGeneric>(driver.loc(@2, @5), driver.string($2));
      type->types = driver.cast_list<Type>(static_cast<NodeList*>($4));
      $$ = new Prepend(driver.loc(@1, @5), std::unique_ptr<Type>(type.release()));
    }

  // Methods

  method_member
    : attributes kDEF method_kind def_name method_types
    {
      auto instance = $3 == NULL || driver.string($3).compare("self?") == 0;
      auto singleton = $3 != NULL;
      auto incompatible = $1 != NULL;
      Method* decl = new Method(driver.loc(@2, @5), driver.string($4), instance, singleton, incompatible);
      decl->types = driver.cast_list<MethodType>(static_cast<NodeList*>($5));
      $$ = decl;
    }

  attributes
    : %empty
    { $$ = NULL; }
    | kINCOMPATIBLE

  def_name
    : keyword
    | method_name kCOLON

  method_kind
    : %empty
    { $$ = NULL; }
    | kSELF kDOT
    | kSELFQ kDOT

  method_name
    : kOPERATOR
    | kAMP | kHAT | kSTAR | kLT | kEXCLAMATION | kSTAR2 | kBAR | kOUT | kIN
    | method_name0
    | method_name0 kQUESTION
    { $$ = new Token(driver.loc(@1, @2), driver.string($1) + "?"); }
    | method_name0 kEQ
    { $$ = new Token(driver.loc(@1, @2), driver.string($1) + "="); }
    | tQUOTEDMETHOD
    | tQUOTEDIDENT
    | tEXCLMETHOD

  method_name0
    : tUIDENT
    | tLIDENT
    | identifier_keywords

  identifier_keywords
    : kCLASS | kVOID | kNIL | kANY | kUNTYPED | kTOP | kBOT | kINSTANCE | kBOOL | kSINGLETON
    | kTYPE | kMODULE | kPRIVATE | kPUBLIC | kEND | kINCLUDE | kEXTEND | kPREPEND
    | kATTRREADER | kATTRACCESSOR | kATTRWRITER | kDEF | kEXTENSION | kINCOMPATIBLE
    | kUNCHECKED

  method_types
    : %empty
    { $$ = driver.list(); }
    | method_types kBAR method_type
    { $$ = driver.merge(static_cast<NodeList*>($1), unique_ptr<Node>($3)); }
    | method_type
    { $$ = driver.list(unique_ptr<Node>($1)); }

  method_type
    : type_params params_opt block_opt kARROW type
    {
      std::unique_ptr<TypeProc> sig = std::make_unique<TypeProc>(driver.loc(@1, @5));
      sig->params = driver.cast_list<Param>(static_cast<NodeList*>($2));
      sig->ret = driver.type($5);

      MethodType* type = new MethodType(driver.loc(@1, @5), move(sig));
      type->typeParams = driver.cast_list<TypeParam>(static_cast<NodeList*>($1));
      if ($3) {
        type->block = unique_ptr<Block>(static_cast<Block*>($3));
      }
      $$ = type;
    }

  type_params
    : %empty
    { $$ = driver.list(); }
    | kLBRACKET type_params0 kRBRACKET
    { $$ = $2; }

  type_params0
    : tUIDENT
    { $$ = driver.list(make_unique<TypeParam>(driver.loc(@1, @1), driver.string($1), "", false)); }
    | type_params0 kCOMMA tUIDENT
    { $$ = driver.merge(static_cast<NodeList*>($1), make_unique<TypeParam>(driver.loc(@3, @3), driver.string($3), "", false)); }

  params_opt
    : %empty
    { $$ = driver.list(); }
    | kLPAREN kRPAREN
    { $$ = driver.list(); }
    | kLPAREN kCOMMA kRPAREN
    { $$ = driver.list(); }
    | kLPAREN params kRPAREN
    { $$ = $2; }

  block_opt
    : %empty
    { $$ = NULL; }
    | kLBRACE block_type kRBRACE
    { $$ = new Block(driver.loc(@1, @3), std::unique_ptr<TypeProc>(static_cast<TypeProc*>($2)), false); }
    | kQUESTION kLBRACE block_type kRBRACE
    { $$ = new Block(driver.loc(@1, @3), std::unique_ptr<TypeProc>(static_cast<TypeProc*>($3)), true); }

  block_type
    : kLPAREN kRPAREN kARROW type
    { $$ = new TypeProc(driver.loc(@1, @4), driver.type($4)); }
    | kLPAREN params kRPAREN kARROW type
    {
      TypeProc* sig = new TypeProc(driver.loc(@1, @5), driver.type($5));
      sig->params = driver.cast_list<Param>(static_cast<NodeList*>($2));
      $$ = sig;
    }
    | kARROW simple_type
    { $$ = new TypeProc(driver.loc(@1, @2), driver.type($2)); }

  params
    : required_positional kCOMMA params
    { $$ = driver.merge(std::unique_ptr<Node>($1), static_cast<NodeList*>($3)); }
    | required_positional
    { $$ = driver.list(std::unique_ptr<Node>($1)); }
    | optional_positionals

  required_positional
    : type var_name_opt
    { $$ = new Param(driver.loc(@1, @2), driver.string($2), driver.type($1), false, false, false); }

  optional_positionals
    : optional_positional kCOMMA optional_positionals
    { $$ = driver.merge(std::unique_ptr<Node>($1), static_cast<NodeList*>($3)); }
    | optional_positional
    { $$ = driver.list(std::unique_ptr<Node>($1)); }
    | rest_positionals

  optional_positional
    : kQUESTION type var_name_opt
    { $$ = new Param(driver.loc(@1, @3), driver.string($3), driver.type($2), false, true, false); }

  rest_positionals
    : rest_positional kCOMMA rest_positionals
    { $$ = driver.merge(std::unique_ptr<Node>($1), static_cast<NodeList*>($3)); }
    | rest_positional
    { $$ = driver.list(std::unique_ptr<Node>($1)); }
    | keywords

  rest_positional
    : kSTAR type var_name_opt
    { $$ = new Param(driver.loc(@1, @3), driver.string($3), driver.type($2), false, false, true); }

  keywords
    : %empty
    { $$ = driver.list(); }
    | required_keyword kCOMMA keywords
    { $$ = driver.merge(std::unique_ptr<Node>($1), static_cast<NodeList*>($3)); }
    | required_keyword
    { $$ = driver.list(std::unique_ptr<Node>($1)); }
    | optional_keyword kCOMMA keywords
    { $$ = driver.merge(std::unique_ptr<Node>($1), static_cast<NodeList*>($3)); }
    | optional_keyword
    { $$ = driver.list(std::unique_ptr<Node>($1)); }
    | rest_keyword
    { $$ = driver.list(std::unique_ptr<Node>($1)); }

  required_keyword
    : keyword_name type var_name_opt
    { $$ = new Param(driver.loc(@1, @2), driver.string($1), driver.type($2), true, false, false); }

  optional_keyword
    : kQUESTION keyword_name type var_name_opt
    { $$ = new Param(driver.loc(@1, @3), driver.string($2), driver.type($3), true, false, false); }

  rest_keyword
    : kSTAR2 type var_name_opt
    { $$ = new Param(driver.loc(@1, @3), driver.string($3), driver.type($2), false, false, true); }

  var_name_opt
    : %empty
    { $$ = NULL; }
    | tLIDENT
    | tINTERFACEIDENT
    | tQUOTEDMETHOD

  keyword_name
    : keyword
    | identifier_keywords kCOLON

  keyword
    : tUKEYWORD
    { static_cast<Token*>($1)->str.pop_back(); }
    | tLKEYWORD
    { static_cast<Token*>($1)->str.pop_back(); }

  // Types

  type
    : simple_type
    | type kBAR type
    {
      std::vector<unique_ptr<Type>> types;
      if(TypeUnion* u = dynamic_cast<TypeUnion*>($1)) {
        for (auto &type : u->types) {
          types.emplace_back(move(type));
        }
      } else {
        types.emplace_back(driver.type($1));
      }
      types.emplace_back(driver.type($3));
      $$ = new TypeUnion(driver.loc(@1, @3), move(types));
    }
    | type kAMP type
    {
      std::vector<unique_ptr<Type>> types;
      if(TypeIntersection* u = dynamic_cast<TypeIntersection*>($1)) {
        for (auto &type : u->types) {
          types.emplace_back(move(type));
        }
      } else {
        types.emplace_back(driver.type($1));
      }
      types.emplace_back(driver.type($3));
      $$ = new TypeIntersection(driver.loc(@1, @3), move(types));
    }

  simple_type
    : kBOOL
    { $$ = new TypeBool(driver.loc(@1, @1)); }
    | kTRUE
    { $$ = new TypeTrue(driver.loc(@1, @1)); }
    | kFALSE
    { $$ = new TypeFalse(driver.loc(@1, @1)); }
    | kNIL
    { $$ = new TypeNil(driver.loc(@1, @1)); }
    | kSELF
    { $$ = new TypeSelf(driver.loc(@1, @1)); }
    | kSELFQ
    { $$ = new TypeSelfQ(driver.loc(@1, @1)); }
    | kVOID
    { $$ = new TypeVoid(driver.loc(@1, @1)); }
    | kUNTYPED
    { $$ = new TypeUntyped(driver.loc(@1, @1)); }
    | tSTRING
    { $$ = new TypeString(driver.loc(@1, @1), driver.string($1)); }
    | kTOP
    { $$ = new TypeTop(driver.loc(@1, @1)); }
    | kBOT
    { $$ = new TypeBot(driver.loc(@1, @1)); }
    | kINSTANCE
    { $$ = new TypeInstance(driver.loc(@1, @1)); }
    | kANY
    { $$ = new TypeAny(driver.loc(@1, @1)); }
    | kCLASS
    { $$ = new TypeClass(driver.loc(@1, @1)); }
    | tINTEGER
    { $$ = new TypeInteger(driver.loc(@1, @1), driver.string($1)); }
    | tSYMBOL
    { $$ = new TypeSymbol(driver.loc(@1, @1), driver.string($1)); }
    | qualified_name
    { $$ = new TypeSimple(driver.loc(@1, @1), driver.string($1)); }
    | qualified_name kLBRACKET type_list kRBRACKET
    {
      TypeGeneric* type = new TypeGeneric(driver.loc(@1, @4), driver.string($1));
      type->types = driver.cast_list<Type>(static_cast<NodeList*>($3));
      $$ = type;
    }
    | kLBRACKET type_list kRBRACKET
    {
      TypeTuple* tuple = new TypeTuple(driver.loc(@1, @3));
      tuple->types = driver.cast_list<Type>(static_cast<NodeList*>($2));
      $$ = tuple;
    }
    | kLBRACKET kRBRACKET
    { $$ = new TypeTuple(driver.loc(@1, @1)); }
    | kLPAREN type kRPAREN
    { $$ = $2; }
    | kSINGLETON kLPAREN class_name kRPAREN
    { $$ = new TypeSingleton(driver.loc(@1, @4), driver.string($3)); }
    | simple_type kQUESTION
    { $$ = new TypeNilable(driver.loc(@1, @2), driver.type($1)); }
    | kHAT proc_type
    { $$ = new Block(driver.loc(@1, @2), std::unique_ptr<TypeProc>(static_cast<TypeProc*>($2)), false); }
    | record_type

  type_list
    : type
    { $$ = driver.list(unique_ptr<Node>($1)); }
    | type_list kCOMMA type
    { $$ = driver.merge(static_cast<NodeList*>($1), unique_ptr<Node>($3)); }

  proc_type
    : kLPAREN kRPAREN kARROW simple_type
    { $$ = new TypeProc(driver.loc(@1, @4), driver.type($4)); }
    | kLPAREN params kRPAREN kARROW simple_type
    {
      TypeProc* sig = new TypeProc(driver.loc(@1, @5), driver.type($5));
      sig->params = driver.cast_list<Param>(static_cast<NodeList*>($2));
      $$ = sig;
    }
    | kARROW simple_type
    { $$ = new TypeProc(driver.loc(@1, @2), driver.type($2)); }

  record_type
    : kLBRACE record_fields kRBRACE
    {
      Record* record = new Record(driver.loc(@1, @3));
      record->fields = driver.cast_list<RecordField>(static_cast<NodeList*>($2));
      $$ = record;
    }

  record_fields
    : record_field
    { $$ = driver.list(unique_ptr<Node>($1)); }
    | record_field kCOMMA record_fields
    { $$ = driver.merge(unique_ptr<Node>($1), static_cast<NodeList*>($3)); }

  record_field
    : tSYMBOL kFATARROW type
    { $$ = new RecordField(driver.loc(@1, @3), driver.string($1), driver.type(($3))); }
    | tSTRING kFATARROW type
    { $$ = new RecordField(driver.loc(@1, @3), driver.string($1), driver.type(($3))); }
    | tINTEGER kFATARROW type
    { $$ = new RecordField(driver.loc(@1, @3), driver.string($1), driver.type(($3))); }
    | keyword type
    { $$ = new RecordField(driver.loc(@1, @2), driver.string($1), driver.type(($2))); }

  // Names

  namespace
    : %empty
    { $$ = NULL; }
    | kCOLON2 tNAMESPACE
    { $$ = new Token(driver.loc(@1, @2), driver.string($1) + driver.string($2)); }
    | tNAMESPACE
    | kCOLON2

  qualified_name
    : namespace simple_name
    { $$ = new Token(driver.loc(@1, @2), driver.string($1) + driver.string($2)); }

  simple_name
    : tUIDENT
    | tLIDENT
    | tINTERFACEIDENT
%%

void rbs_parser::Parser::error(const location_type& loc, const std::string& m) {
  std::stringstream what;
  what << loc.begin.line << ":" << std::to_string(loc.begin.column) << "-";
  what << loc.end.line << ":" << std::to_string(loc.end.column) << ": ";
  what << m;
  throw rbs_parser::ParseError(what.str());
}
